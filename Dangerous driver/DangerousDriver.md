1) Реверсим драйвер, делаем основные выводы: управление через ioctl, требуется аутентификация через отправку строки с паролем и взятие от неё crc32, ioctl позволяет записывать произвольные данные по любому адресу
2) Обходим аутентификацию: перебираем или находим коллизию
3) Выбираем стратегию эксплуатации: в моем примере - перезапись modprobe_path с последующим его триггером через запуск невалидного ELF
4) Определяем смещение от kernel base до modprobe_path, первый сливается в модуле, второй можно получить на тестовой vm от root читая `/proc/kallsyms`
5) Перезаписываем modprobe_path на скрипт с payload: смену прав на флаг, проверяем через `/proc/sys/kernel/modprobe`
6) Вызываем триггер, запуская невалидный ELF
7) Читаем флаг
Пример эксплойта в `exploit.c`, доставка - через wget.