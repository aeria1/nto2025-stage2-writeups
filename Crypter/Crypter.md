## Write Up

Запускаем Wireshark. Экспортируем все передаваемые по SMB файлы (Файл->Экспортировать объекты->SMB...). 
Из полученного списка файлов нас интересуют следующие:
- Нажми меня.docx.exe - инициатор атаки, это скрипт AutoHotKey, упакованный в .exe. Он генерирует пароль в формате `{много чисел}`, запускает шифратор и передаёт ему, запускает dnscat2-client, устанавливает связь с компьютером злоумышленника, посылает сгенерированный ключ.
- Зарплаты.docx.exe - шифратор на python, упакованный с помощью pyinstaller в .exe.
- Отчёты.docx.exe - dnscat2-client, используется для создания dns-tunnel до компьютера злоумышленника.


Как понять, что это за файлы? Самое первое, что должно быть на уме, это программа `strings` под линуксом. Она выводит все печатные символы файла. Можно и через HxD глянуть, но будет сложнее.

Вот то, что дало бы понять, что это за файлы, и что с ними нужно было делать:
 - Нажми меня.docx.exe: в самом конце файла есть куча текста и надо заметить AutoHotKey, чуть выше будет написать скрипт. При желании можно декомпилировать его через exe2ahk. -> понимаем, что ключ генерируется случайным образом, затем запускаются программы и вних посылают ключ, копаем дальше.
 - Зарплаты.docx.exe: в конце файла можно увидеть python38.dll, что намекает на использование питона версии 3.8 внутри. Если воспользоваться DetectItEasy, то он подскажет, что этот ехе был упакован с помощью pyinstaller. -> гуглим как декомпилировать -> pyinstxtractor, uncompyle-6 -> получаем исходник encryptAllFilesBugaga.py -> понимаем, что ни флага, ни ключа тут нет и идём копать дальше.
 - Отчёты.docx.exe: в strings находим, что это какое-то ПО, связанное с dns -> гуглим найденные слова внутри -> понимаем, что это dns2-client, и что была использована атака по DNS Tunnel -> стоит поискать следы работы этой программы, смотрим протокол DNS в траффике -> находим в самом конце похожие пакеты -> ПКМ, следовать, UDP -> видим кучу непонятный сайтов вида `XXXXXXXX.evilsite.com`, причём длина домена 3-го уровня меняется -> в двух местах замечаем выбивающиеся из общего фона более длинные строки, дешифруем этот hex код, получаем `{251253381326319248146188313376236273}`, это и есть ключ для шифровальщика.

В шифровальщике уже есть функция для расшифрования. Просто нужно строчку одну поменять в конце на write_dec... Запускаем программу в одной директории с flag.enc. На вход программе подаём найденный ключ `{251253381326319248146188313376236273}` и получаем флаг.