Исполняемый файл принимает путь к файлу и читает его в массив 32x32=1024 байта.
Далее работает с этим массивом как матрицей 32x32. Индексация с 0 до 31 включительно.
Координатную сетку ведем слева-направо сверху-вниз, потому что функция getxy(0, 0)
возвращает первый элемент массива. Название PostNeoGothic намекает на PNG, а
одна из строк в исполняемом файле говорит о черном тексте на белом фоне.
Бинарь сравнивает ксоры каждых трех байт диагонали (слева-направо сверху-вниз) с 
захардкоженными значениями. То есть для восстановления файла уже есть следующие значения:
```
a[0][0] ^ a[1][1] ^ a[2][2]
a[1][1] ^ a[2][2] ^ a[3][3]
a[2][2] ^ a[3][3] ^ a[4][4]
...
```
Далее бинарь сравнивает ксоры всех прямоугольников 3x2 с захардкоженными значениями. То есть
для восстановления файла есть следующие значения:
```
a[0][0] ^ a[1][0] ^ a[2][0] ^ a[0][1] ^ a[1][1] ^ a[2][1]
a[1][0] ^ a[2][0] ^ a[3][0] ^ a[1][1] ^ a[2][1] ^ a[3][1]
a[2][0] ^ a[3][0] ^ a[4][0] ^ a[2][1] ^ a[3][1] ^ a[4][1]
...
```
Имея значения ксоров и знания о структуре PNG файла возможно восстановить картинку, чтобы
прочитать флаг. Скрипт далее приводит действия для восстановления картинки.


```python3
import zlib
import os
import shutil
import cv2
import numpy as np


# захардкоженные ксоры из исполняемого бинаря
diagonal_xores = [0xa9, 0x90, 0xaa, 0x40, 0xf6, 0x55, 0xd2, 0x45, 0x7d, 0x3b, 0x9d, 0x4, 0x65, 0xbc, 0x90, 0xc5, 0xc5, 0x5c, 0x14, 0x58, 0x65, 0x6e, 0xb, 0x62, 0xc0, 0x67, 0xbe, 0x60, 0x0, 0x0]
rectangle_xores = [0x95, 0x59, 0x12, 0x22, 0x3a, 0x73, 0x79, 0x65, 0x58, 0x4c, 0x2b, 0x69, 0x23, 0x21, 0xc, 0x7f, 0x36, 0x3, 0x7a, 0x76, 0x22, 0x2c, 0x67, 0x62, 0x23, 0x2b, 0x26, 0xb2, 0xb1, 0x50, 0xf1, 0x9f, 0x36, 0x61, 0x6, 0x1, 0x46, 0x23, 0x9, 0xc, 0xa0, 0x13, 0xdd, 0xca, 0x29, 0xd7, 0x54, 0x52, 0xf0, 0x36, 0x6d, 0x7, 0xe8, 0x29, 0xc6, 0x93, 0x11, 0x82, 0xa3, 0x9b, 0x54, 0xce, 0x1, 0x67, 0xf6, 0x91, 0x58, 0xed, 0x70, 0x76, 0x36, 0x68, 0x6b, 0xe6, 0xc, 0x88, 0x4e, 0x96, 0x27, 0xbf, 0xff, 0x79, 0x9, 0xd, 0x11, 0x64, 0x6a, 0xf2, 0x33, 0xad, 0xf1, 0x7c, 0x72, 0x9b, 0xc, 0x6d, 0xc9, 0x54, 0x19, 0x48, 0xee, 0xeb, 0x44, 0x54, 0x44, 0x47, 0x78, 0x20, 0x2e, 0xc1, 0x82, 0x2d, 0x83, 0x14, 0xb4, 0x56, 0x21, 0x3b, 0x5, 0xba, 0x17, 0xe1, 0x8c, 0x43, 0xba, 0x17, 0xe, 0x61, 0x96, 0x57, 0x55, 0xd7, 0x1a, 0x2c, 0x50, 0x48, 0x2d, 0x67, 0x64, 0xc4, 0xbe, 0x45, 0x55, 0x4, 0xce, 0xd, 0x9d, 0x17, 0xd1, 0x67, 0xac, 0x56, 0x40, 0xdd, 0x7, 0x85, 0x48, 0x73, 0x4e, 0x77, 0xc4, 0x2a, 0x41, 0xa9, 0x4a, 0x33, 0xf6, 0x43, 0xa5, 0x61, 0x20, 0xdf, 0xde, 0x34, 0xc6, 0x15, 0xb0, 0x72, 0x43, 0xdd, 0xbe, 0xda, 0xb4, 0x8b, 0x3f, 0x3b, 0xa8, 0x43, 0x72, 0x6c, 0x57, 0xc, 0x92, 0x7a, 0xaa, 0x87, 0xa7, 0xe, 0x8f, 0xb0, 0x11, 0xbc, 0x51, 0x7e, 0x62, 0x55, 0x6b, 0xcf, 0x1e, 0x85, 0x6c, 0x4f, 0x61, 0xd5, 0x4f, 0xd3, 0x90, 0x3d, 0xeb, 0xbf, 0xa, 0xe, 0x5e, 0xa6, 0xd0, 0x2, 0xa2, 0xc7, 0x41, 0x34, 0xcd, 0x35, 0xb4, 0xf7, 0x35, 0x4e, 0xc7, 0x7c, 0xee, 0xda, 0xc4, 0x83, 0xef, 0xe8, 0x57, 0xcc, 0xae, 0x70, 0x27, 0xbc, 0xae, 0x35, 0xc1, 0xc7, 0x4b, 0x43, 0x79, 0x11, 0x44, 0x3f, 0x2c, 0xa8, 0x6b, 0x30, 0x1f, 0x71, 0xc0, 0x96, 0x7e, 0xe4, 0xbb, 0x66, 0x50, 0x15, 0xa0, 0x32, 0x70, 0xe3, 0xe6, 0x92, 0x39, 0xfb, 0x71, 0x5b, 0x40, 0x96, 0xce, 0xb6, 0x9b, 0x13, 0xd3, 0x7b, 0xdf, 0xec, 0x65, 0x9, 0x26, 0xf0, 0xb3, 0x91, 0xa6, 0xe2, 0xf0, 0x6a, 0xb4, 0x34, 0x2c, 0xd2, 0xf6, 0x1b, 0x4c, 0x18, 0x41, 0x25, 0x10, 0xc, 0x7, 0x9b, 0xea, 0xb7, 0x98, 0x50, 0x30, 0xa4, 0x12, 0xde, 0x76, 0x1b, 0x9d, 0x29, 0xaa, 0x45, 0xa4, 0xdb, 0x9, 0xf, 0x23, 0x2, 0xd, 0x26, 0x8b, 0x9f, 0xb3, 0xd, 0x51, 0xb4, 0x5f, 0x2a, 0xd, 0x16, 0x8f, 0x6a, 0xaa, 0xff, 0xfa, 0xe8, 0xe1, 0x10, 0x5, 0x8b, 0xc4, 0x18, 0x41, 0x7d, 0xab, 0x96, 0xb2, 0x0, 0xef, 0x79, 0x6, 0xf, 0xd1, 0x7a, 0x9e, 0xdf, 0x6c, 0x38, 0xf0, 0x85, 0x93, 0xcd, 0xe, 0xee, 0xa8, 0xe5, 0x40, 0x3b, 0x55, 0xa3, 0x6a, 0xf1, 0xa5, 0x2c, 0xf9, 0x8e, 0xff, 0x93, 0x64, 0xf6, 0xef, 0x55, 0x39, 0x16, 0x6f, 0x38, 0x9a, 0x8, 0x54, 0x82, 0xd5, 0xd0, 0xd0, 0x63, 0xa, 0x32, 0xc9, 0xd0, 0xd0, 0xbe, 0xa4, 0x91, 0xa3, 0x34, 0x3c, 0xfb, 0xbc, 0x5, 0x36, 0xe6, 0xfb, 0xab, 0xc7, 0x95, 0x8e, 0x83, 0xce, 0xc3, 0xcf, 0x2f, 0xd, 0x5c, 0x0, 0x33, 0x4a, 0x8c, 0x5, 0x21, 0xe9, 0x40, 0x70, 0x41, 0xd2, 0x7f, 0x20, 0xf9, 0x79, 0xb, 0xf4, 0x89, 0xd5, 0x92, 0xd4, 0x3c, 0x1, 0xfa, 0xf0, 0xe6, 0x3a, 0x60, 0x25, 0x76, 0x69, 0x7c, 0xd5, 0x19, 0x37, 0x1c, 0xa6, 0x2e, 0x54, 0xb9, 0x27, 0x41, 0x38, 0x6f, 0x92, 0x25, 0x7c, 0x6b, 0xd0, 0xd7, 0x17, 0xbb, 0xe3, 0x64, 0x4f, 0x42, 0x6e, 0x5a, 0xcb, 0x43, 0xa7, 0x99, 0x10, 0x4a, 0xe4, 0x6c, 0x70, 0xe8, 0x77, 0xba, 0xd4, 0x7c, 0x9d, 0x4c, 0x98, 0x8b, 0x62, 0x3b, 0xe4, 0x9, 0x12, 0x11, 0x87, 0xea, 0x2e, 0xfb, 0xbe, 0xae, 0x7e, 0x11, 0xee, 0x3b, 0x30, 0x2b, 0x2a, 0x84, 0xd1, 0x15, 0xe8, 0x15, 0x78, 0x73, 0x7a, 0x94, 0xad, 0x6f, 0xe6, 0x6b, 0xa, 0x43, 0x8f, 0x99, 0xb2, 0x6e, 0xf0, 0xe7, 0xf6, 0xb3, 0xb8, 0xf5, 0xaa, 0x11, 0x5f, 0x7a, 0x29, 0x9c, 0xe5, 0x39, 0x12, 0x41, 0x8, 0xc3, 0x5e, 0x51, 0xf1, 0x7f, 0x61, 0x4d, 0xa7, 0x9f, 0x80, 0x27, 0x84, 0x57, 0x2, 0xb2, 0xc3, 0x70, 0xf3, 0xce, 0xa6, 0x45, 0x36, 0xa0, 0x1b, 0x24, 0x65, 0xb2, 0x0, 0x36, 0x6e, 0x3e, 0x41, 0xa3, 0xdc, 0x7e, 0x2e, 0xf3, 0x83, 0xdf, 0x52, 0xf0, 0x1b, 0xc6, 0x7c, 0x29, 0xd0, 0xc7, 0x5b, 0x69, 0xff, 0x9f, 0xc0, 0x3f, 0x7c, 0x1c, 0xbb, 0x8d, 0x4e, 0x85, 0x70, 0x1b, 0xaa, 0x4e, 0x4, 0xe1, 0x2d, 0xb1, 0xe0, 0x7d, 0xe4, 0x34, 0x4e, 0x1c, 0x71, 0xee, 0x6, 0x16, 0xf2, 0xcb, 0x40, 0x2f, 0xc5, 0xcf, 0x66, 0x2c, 0xac, 0x56, 0xab, 0x10, 0x3b, 0x3a, 0x2a, 0x71, 0xa1, 0xd3, 0x5e, 0x56, 0x30, 0xed, 0xfd, 0x2e, 0xcb, 0xf1, 0x1b, 0x60, 0x54, 0xae, 0x20, 0x1, 0x1f, 0xc5, 0xf5, 0x94, 0xac, 0x51, 0xca, 0x6c, 0x2a, 0x9, 0x98, 0xce, 0xce, 0x40, 0xb, 0xc5, 0x53, 0xa8, 0xe5, 0xbe, 0x82, 0xb0, 0x26, 0x97, 0xe0, 0x9a, 0x7c, 0xa4, 0xec, 0xdd, 0xa1, 0xd1, 0x41, 0x1b, 0x43, 0x1e, 0x61, 0x92, 0x47, 0xfa, 0x28, 0x3f, 0xa2, 0x69, 0x91, 0x61, 0x54, 0xfe, 0xcb, 0x9f, 0x91, 0x56, 0x6e, 0x88, 0x6b, 0x75, 0x3d, 0xe4, 0xa, 0x8f, 0x93, 0xe, 0x48, 0xc1, 0x9f, 0x3f, 0x5, 0xca, 0x9, 0x1d, 0x91, 0xf2, 0xe, 0xd4, 0xe7, 0xc3, 0xd8, 0x3, 0x76, 0xa8, 0xae, 0x71, 0xf0, 0xcb, 0x18, 0x8b, 0xd9, 0x28, 0xa7, 0xfe, 0x8, 0x3a, 0xaa, 0x69, 0xae, 0xb4, 0xed, 0x40, 0x42, 0xdd, 0xf0, 0xd4, 0xd, 0x1b, 0x5a, 0xe, 0xce, 0x6e, 0xdf, 0x26, 0xe7, 0xb4, 0xe2, 0x5e, 0x4f, 0x66, 0x5a, 0xf3, 0xcc, 0xd6, 0x2a, 0x24, 0xa, 0x65, 0xaf, 0x5d, 0xa3, 0xe7, 0x2c, 0xb3, 0x43, 0x2c, 0x3d, 0xad, 0x91, 0xdc, 0xdf, 0x2a, 0x1, 0xc2, 0xa1, 0xf2, 0xb9, 0x2e, 0xf4, 0x0, 0x0, 0x49, 0xc, 0x42, 0x4f, 0xa4, 0xa8, 0x8c, 0xa0, 0xe2, 0x82, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
# базовый массив
arr = [-1] * 1024  # -1 значит байт неизвестен

# возвращает у массива значение по координатам
def getxy(a: list, x: int, y: int) -> int:
    return a[y * 32 + x]

# устанавливает данному массиву переданное значение по координатам
def setxy(a: list, x: int, y: int, v: int):
    a[y * 32 + x] = v

# возвращает ксор прямоугольника с верхней левой вершиной в координатах x, y
def getrectxor(x, y):
    assert 0 <= x <= 29 and 0 <= y <= 30
    return rectangle_xores[y * 30 + x]

# выводит массив для анализа
def show(a: list):
    for y in range(32):
        row = []
        for x in range(32):
            row.append(getxy(a, x, y))
        print(" ".join([f"0x{v:02X}" for v in row]))

# возможно сразу установить сигнатуру PNG
magic_bytes = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
for i in range(len(magic_bytes)):
    setxy(arr, i, 0, magic_bytes[i])

# далее необходимо знание структуры PNG чанков
# https://habr.com/ru/companies/selectel/articles/856084/

# 2 старших байта длины второго чанка точно нулевые, т.к. общий размер картинки менее 1024 байт
setxy(arr, 1, 1, 0)
setxy(arr, 2, 1, 0)

# зная arr[0][0] и arr[1][1], можно восстановить всю диагональ
for i in range(2, 32):
    v = getxy(arr, i - 2, i - 2) ^ getxy(arr, i - 1, i - 1) ^ diagonal_xores[i - 2]
    setxy(arr, i, i, v)

# в конце ксоров прямоугольников идут нули. Нужно посчитать сколько их
zero_rectangles = 0
for i in range(len(rectangle_xores) - 1, 0, -1):
    if rectangle_xores[i] == 0:
        zero_rectangles += 1
    else:
        break
print("Кол-во нулей в ксоре прямоугольников в конце: ", zero_rectangles) # 91


# забить нули в конце
# 4 полных ряда
for x in range(32):
    setxy(arr, x, 31, 0)
    setxy(arr, x, 30, 0)
    setxy(arr, x, 29, 0)
    setxy(arr, x, 28, 0)
# один прямоугольник на пятом снизу ряду
for x in range(29, 32):
    setxy(arr, x, 27, 0)

# возможно восстановить начало пятого снизу ряда
for x in range(28, -1, -1):
    v = (getrectxor(x, 27) ^ getxy(arr, x + 1, 27) ^ getxy(arr, x + 2, 27) ^ getxy(arr, x, 28) ^
         getxy(arr, x + 1, 28) ^ getxy(arr, x + 2, 28))
    setxy(arr, x, 27, v)
# IEND чанк говорит об успешности извлечения последнего ненулевого ряда

# далее необходимо знание структуры IHDR чанка
# https://www.libpng.org/pub/png/spec/1.2/PNG-Chunks.html
# длина IHDR всегда 13 байт
setxy(arr, 8, 0, 0)
setxy(arr, 9, 0, 0)
setxy(arr, 10, 0, 0)
setxy(arr, 11, 0, 0xD)
# название чанка
setxy(arr, 12, 0, 0x49)  # I
setxy(arr, 13, 0, 0x48)  # H
setxy(arr, 14, 0, 0x44)  # D
setxy(arr, 15, 0, 0x52)  # R
# маловероятно, что длина или высота больше 65535 пикселей, поэтому первые два байта размеров можно занулить
# старшие два байта ширины
setxy(arr, 16, 0, 0)
setxy(arr, 17, 0, 0)
# старшие два байта высоты
setxy(arr, 20, 0, 0)
setxy(arr, 21, 0, 0)
# compression, filter, interlace также можно занулить
setxy(arr, 26, 0, 0)  # compression
setxy(arr, 27, 0, 0)  # filter
setxy(arr, 28, 0, 0)  # значение 1 (Adam7) сегодня не используется
# при желании interlace (0 или 1) также можно добавить как значение для брута,
# но значение 1 (Adam7) сегодня не используется

# по известному getrectxor(0, 0) можно вычислить arr[0, 1]
v = (getrectxor(0, 0) ^ getxy(arr, 0, 0) ^ getxy(arr, 1, 0) ^ getxy(arr, 2, 0) ^
     getxy(arr, 1, 1) ^ getxy(arr, 2, 1))
setxy(arr, 0, 1, v)

# также возможно вывести часть второго сверху ряда
for i in range(3, 18):
    v = (getrectxor(i - 2, 0) ^ getxy(arr, i - 2, 0) ^ getxy(arr, i - 1, 0) ^
         getxy(arr, i, 0) ^ getxy(arr, i - 2, 1) ^ getxy(arr, i - 1, 1))
    setxy(arr, i, 1, v)

# в полученных байтах видно начало чанка с комментарием
# возможно занулить старшие два байта третьего блока, потому что мы знаем длину tEXt чанка
setxy(arr, 3, 2, 0)
setxy(arr, 4, 2, 0)
# и вывести начало третьего ряда
v = (getrectxor(1, 1) ^ getxy(arr, 1, 1) ^ getxy(arr, 2, 1) ^ getxy(arr, 3, 1) ^
     getxy(arr, 2, 2) ^ getxy(arr, 3, 2))
setxy(arr, 1, 2, v)
v = (getrectxor(0, 1) ^ getxy(arr, 0, 1) ^ getxy(arr, 1, 1) ^ getxy(arr, 2, 1) ^
     getxy(arr, 1, 2) ^ getxy(arr, 2, 2))
setxy(arr, 0, 2, v)

# подсчитать crc по данным чанка
def png_crc(chunk_data):
    tmp_crc = zlib.crc32(bytes(chunk_data)) & 0xffffffff
    return tuple(tmp_crc.to_bytes(4, 'big'))

# починить чексумму IDAT блока. Размер и начало IDAT блока будут понятны после брута
def fix_idat_crc(arr):
    crc = png_crc(arr[0x47:0x36D])
    arr[0x36D] = crc[0]
    arr[0x36E] = crc[1]
    arr[0x36F] = crc[2]
    arr[0x370] = crc[3]

# учитывая размер картинки в байтах, можно предположить, что длина и ширина
# не превышают 256 в пикселях, что позволяет занулить третьи байты длины и ширины
# это предположение можно не делать и перебирать размеры
# до разумных пределов изображения (например, до 1024 пикселей), что
# немного продлит время перебора, но оставит его в перебираемых границах.
# в рамках данного скрипта будем перебирать длину до 256 пикселей,
# поэтому можно занулить третий старший байт у длины и ширины
setxy(arr, 18, 0, 0)
setxy(arr, 22, 0, 0)

found = 0  # найден подходящий экземпляр IDAT чанка
shutil.rmtree("./imgs")
os.mkdir("./imgs")
for width in range(5, 256):
    if found:
        break
    for height in range(5, 256):
        # цвет и глубина имеют только определенные разрешенные значения
        for color, depth in [(0, 1), (0, 2), (0, 4), (0, 8), (0, 16), (2, 8), (2, 16), (4, 8), (4, 16), (6, 8), (6, 16)]:
            brute_arr = arr.copy()
            # установим 0xFF вместо неизвестных байт
            brute_arr = [0xFF if x == -1 else x for x in brute_arr]
            # установка перебираемых байт
            setxy(brute_arr, 19, 0, width)
            setxy(brute_arr, 23, 0, height)
            setxy(brute_arr, 24, 0, depth)
            setxy(brute_arr, 25, 0, color)
            # подсчет чексуммы IDAT
            crc = png_crc(brute_arr[12:29])
            setxy(brute_arr, 29, 0, crc[0])
            setxy(brute_arr, 30, 0, crc[1])
            setxy(brute_arr, 31, 0, crc[2])
            # выведение второго ряда
            for x in range(18, 32):
                v = (getrectxor(x - 2, 0) ^ getxy(brute_arr, x - 2, 0) ^ getxy(brute_arr, x - 1, 0) ^
                     getxy(brute_arr, x, 0) ^ getxy(brute_arr, x - 2, 1) ^ getxy(brute_arr, x - 1, 1))
                setxy(brute_arr, x, 1, v)

            # подсчет чексуммы tEXt
            text_crc = png_crc(brute_arr[0x25:0x3F])
            # проверка сходится ли 3 байта чексумма с выведенной ранее в начале третьего ряда
            if text_crc[1] != getxy(brute_arr, 0, 2) or text_crc[2] != getxy(brute_arr, 1, 2) or text_crc[3] != getxy(brute_arr, 2, 2):
                continue
            # установить первый байт чексуммы в конец второго ряда
            setxy(brute_arr, 31, 1, text_crc[0])

            # вывести третий ряд
            for x in range(5, 32):
                v = (getrectxor(x - 2, 1) ^ getxy(brute_arr, x - 2, 1) ^ getxy(brute_arr, x - 1, 1) ^
                     getxy(brute_arr, x, 1) ^ getxy(brute_arr, x - 2, 2) ^ getxy(brute_arr, x - 1, 2))
                setxy(brute_arr, x, 2, v)

            # восстановить чексумму IDAT, чтобы можно было смотреть картинку
            fix_idat_crc(brute_arr)
            arr = brute_arr
            found  = 1
            break

# На компьютере со средней конфигурацией перебор выше занял 1 минуту.
# На данный момент известны первые три ряда сверху и часть картинки в конце с IEND чанком
# только на основе ксоров продвинуться нельзя, но можно перебирать байты и выводить оставшуюся
# часть IDAT на основе ксоров

# функция принимает массив, координаты байта в самому верхнем неизвестном ряду справа от известной диагонали,
# значение этого байта. Далее выводит неизвестный ряд на основе ксоров и известного ряда выше и возвращает
# новый массив с выведенным рядом
def deduce_row(original_arr, brute_x, brute_y, brute_value):
    arr = original_arr.copy()
    # установить угадываемый байт
    setxy(arr, brute_x, brute_y, brute_value)
    # вывести байты слева от диагонали
    for x in range(brute_x - 2, -1, -1):
        v = (getrectxor(x, brute_y - 1) ^ getxy(arr, x, brute_y - 1) ^ getxy(arr, x + 1, brute_y - 1) ^
             getxy(arr, x + 2, brute_y - 1) ^ getxy(arr, x + 1, brute_y) ^ getxy(arr, x + 2, brute_y))
        setxy(arr, x, brute_y, v)
    # вывести байты справа от диагонали
    for x in range(brute_x + 1, 32):
        v = (getrectxor(x - 2, brute_y - 1) ^ getxy(arr, x - 2, brute_y - 1) ^ getxy(arr, x - 1, brute_y - 1) ^
             getxy(arr, x, brute_y - 1) ^ getxy(arr, x - 2, brute_y) ^ getxy(arr, x - 1, brute_y))
        setxy(arr, x, brute_y, v)
    fix_idat_crc(arr)
    return arr

# путем экспериментов можно обнаружить, что наличие необходимого количества корректных байт
# в начале IDAT чанка будет отображаться даже если последующие байты некорректны с точки зрения
# сжатия IDAT пикселей. Достаточно подобрать последующие три неизвестных сверху ряда, чтобы увидеть
# начало изображения. Для каждого ряда нужно перебирать 1 байт и выводить остальные на основе ксоров
brute_x_1, brute_y_1 = 4, 3  # координаты байта справа от диагонали перебираемого ряда
found = 0  # нужные три ряда найдены
for b1 in range(0x2B, 256):  # 0x2B
    if found: break
    brute_arr_1 = deduce_row(arr, brute_x_1, brute_y_1, b1)
    brute_x_2, brute_y_2 = 5, 4
    for b2 in range(0, 256):  # 0x88
        if found: break
        brute_arr_2 = deduce_row(brute_arr_1, brute_x_2, brute_y_2, b2)
        brute_x_3, brute_y_3 = 6, 5
        for b3 in range(0, 256):  # 0x9C
            if found: break
            brute_arr_3 = deduce_row(brute_arr_2, brute_x_3, brute_y_3, b3)
            # попытаться открыть массив как картинку
            np_arr = np.frombuffer(bytes(brute_arr_3), np.uint8)
            img = cv2.imdecode(np_arr, cv2.IMREAD_ANYDEPTH)
            if img is None: continue
            arr = brute_arr_3
            found = 1

# На компьютере со средней конфигурацией перебор выше занял 3 минуты
# Возможно было сохранять все возможные варианты, однако перебор выдаст только
# один возможный

# Далее возможно перебирать каждый ряд по отдельности и находить
# подходящее значение визуально (черный текст на белом фоне)
# достаточно подобрать еще 3 ряда, чтобы прочитать флаг

# значения для известных байт справа от диагонали
known_bytes = [] # [102, 137, 6]
# выводим диагонали на основе известных байт
for row in range(6, 6 + len(known_bytes)):
    arr = deduce_row(arr, row + 1, row, known_bytes[row - 6])

# перебираем байт справа от диагонали для нового ряда
row = 6 + len(known_bytes)
brute_x, brute_y = row + 1, row
for b in range(256):
    brute_arr = deduce_row(arr, brute_x, brute_y, b)
    np_arr = np.frombuffer(bytes(brute_arr), np.uint8)
    img = cv2.imdecode(np_arr, cv2.IMREAD_ANYDEPTH)
    if img is None: continue
    arr = brute_arr
    # сохраняем все корректные для визуального отбора
    with open(f'./imgs/{str(b).zfill(3)}.png', "wb") as f:
        f.write(bytes(arr))
```